#pragma kernel minMax
#pragma kernel compactActiveBlocks
#pragma kernel generateTriangles

#define B_DIM_X 8
#define B_DIM_Y 4
#define B_DIM_Z 4
#define B_DIM B_DIM_X*B_DIM_Y*B_DIM_Z
#define WARP_SIZE 32

struct MinMaxPair {
  float min;
  float max;
};

int3 size;
int3 numBlocks;
int3 c_numBlocks;
RWStructuredBuffer<MinMaxPair> minMaxBuffer;

groupshared MinMaxPair sharedMinMaxBuffer[B_DIM];

RWStructuredBuffer<float> voxelBuffer;

[numthreads(B_DIM_X, B_DIM_Y, B_DIM_Z)]
void minMax (
  uint3 gtid : SV_GroupThreadID,
  uint3 gid : SV_GroupID,
  uint gidx : SV_GroupIndex
)
{
  uint gridPos = (gid.z*(B_DIM_Z-1)+gtid.z)*size.x*size.y + (gid.y*(B_DIM_Y-1)+gtid.y)*size.x + (gid.x*(B_DIM_X-1)+gtid.x);

  float val1 = voxelBuffer[gridPos];
  sharedMinMaxBuffer[gidx].min = val1;
  sharedMinMaxBuffer[gidx].max = val1;

  GroupMemoryBarrierWithGroupSync();
  for(uint i=B_DIM/2; i > 0; i>>=1) {
    MinMaxPair pair1 = sharedMinMaxBuffer[gidx];
    MinMaxPair pair2 = sharedMinMaxBuffer[gidx+i];
    GroupMemoryBarrierWithGroupSync();
    if(gidx < i) {
      sharedMinMaxBuffer[gidx].min = min(pair1.min, pair2.min);
      sharedMinMaxBuffer[gidx].max = max(pair1.max, pair2.max);
    }
    GroupMemoryBarrierWithGroupSync();
  }

  if(gidx == 0) {
    minMaxBuffer[gid.z*numBlocks.x*numBlocks.y + gid.y*numBlocks.x + gid.x] = sharedMinMaxBuffer[gidx];
  }
}

extern float isoValue;
RWStructuredBuffer<uint> activeBlkNum;
RWStructuredBuffer<int> compactedBlkArray;
groupshared int sharedCompactedBlkArray[B_DIM];

[numthreads(B_DIM_X, B_DIM_Y, B_DIM_Z)]
void compactActiveBlocks(
  uint3 dtid : SV_DispatchThreadID,
  uint3 gtid : SV_GroupThreadID,
  uint3 gid : SV_GroupID,
  uint gidx : SV_GroupIndex
)
{
  uint3 numBlocksInGroup = numBlocks - gid * uint3(B_DIM_X, B_DIM_Y, B_DIM_Z);
  uint maxValidGidx = min(B_DIM, (numBlocksInGroup.z-1)*B_DIM_X*B_DIM_Y + (numBlocksInGroup.y-1)*B_DIM_X + numBlocksInGroup.x) - 1;

  bool valid = gtid.x < numBlocksInGroup.x && gtid.y < numBlocksInGroup.y && gtid.z < numBlocksInGroup.z;

  uint blockIdx = dtid.z*numBlocks.x*numBlocks.y + dtid.y*numBlocks.x + dtid.x;
  MinMaxPair pair = minMaxBuffer[blockIdx];
  bool active = pair.min < isoValue && pair.max > isoValue && valid;
  sharedCompactedBlkArray[gidx] = active;

  GroupMemoryBarrierWithGroupSync();

  for (uint offset = 1; offset < B_DIM; offset <<= 1) {
    uint otherActive = sharedCompactedBlkArray[gidx-offset];
    GroupMemoryBarrierWithGroupSync();
    if (gidx >= offset) {
      sharedCompactedBlkArray[gidx] += otherActive;
    }
    GroupMemoryBarrierWithGroupSync();
  }

  uint index = sharedCompactedBlkArray[gidx];
  if (gidx == maxValidGidx) {
    InterlockedAdd(activeBlkNum[0], sharedCompactedBlkArray[gidx], sharedCompactedBlkArray[gidx]);
  }

  AllMemoryBarrierWithGroupSync();

  if (valid) {
    compactedBlkArray[blockIdx] = active ? index + sharedCompactedBlkArray[maxValidGidx] - 1 : -1;
  }
}

static const uint4 neighborMappingTable[] = {
  uint4(0,0,0,0),
  uint4(1,0,0,1),
  uint4(0,1,0,0),
  uint4(0,0,0,1),
  uint4(0,0,1,0),
  uint4(1,0,1,1),
  uint4(0,1,1,0),
  uint4(0,0,1,1),
  uint4(0,0,0,2),
  uint4(1,0,0,2),
  uint4(1,1,0,2),
  uint4(0,1,0,2),
};

static const uint numTrisLookup[] = {
0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,2,1,
2,2,3,2,3,3,4,2,3,3,4,3,4,4,3,1,
2,2,3,2,3,3,4,2,3,3,4,3,4,4,3,2,
3,3,2,3,4,4,3,3,4,4,3,4,5,5,2,1,
2,2,3,2,3,3,4,2,3,3,4,3,4,4,3,2,
3,3,4,3,4,4,5,3,4,4,5,4,5,5,4,2,
3,3,4,3,4,2,3,3,4,4,5,4,5,3,2,3,
4,4,3,4,5,3,2,4,5,5,4,5,2,4,1,1,
2,2,3,2,3,3,4,2,3,3,4,3,4,4,3,2,
3,3,4,3,4,4,5,3,2,4,3,4,3,5,2,2,
3,3,4,3,4,4,5,3,4,4,5,4,5,5,4,3,
4,4,3,4,5,5,4,4,3,5,2,5,4,2,1,2,
3,3,4,3,4,4,5,3,4,4,5,2,3,3,2,3,
4,4,5,4,5,5,2,4,3,5,4,3,2,4,1,3,
4,4,5,4,5,3,4,4,5,5,2,3,4,2,1,2,
3,3,2,3,4,2,1,3,2,4,1,2,1,1,0,
};

RWStructuredBuffer<int> marchingCubesEdgeTable;
RWStructuredBuffer<float3> vertexBuffer;
RWStructuredBuffer<float3> normalBuffer;
RWStructuredBuffer<int> indexBuffer;

RWStructuredBuffer<int> globalVertexOffset;
RWStructuredBuffer<int> globalIndexOffset;

groupshared float sharedVoxelBuffer[B_DIM];
groupshared bool3 sharedXyzEdges[B_DIM];
groupshared int numVerts[B_DIM];
groupshared int numTris[B_DIM];

int vecToIdx(uint3 vec) {
  return vec.z*B_DIM_X*B_DIM_Y + vec.y*B_DIM_X + vec.x;
}

float accessSharedVoxelBuffer(uint3 val) {
  if (val.x >= B_DIM_X || val.y >= B_DIM_Y || val.z >= B_DIM_Z ||
      val.x < 0 || val.y < 0 || val.z < 0) {
    return 0.0f;
  } else {
    return sharedVoxelBuffer[vecToIdx(val)];
  }
}

float accessGlobalVoxelBuffer(int3 val) {
  if (val.x >= size.x || val.y >= size.y || val.z >= size.z ||
      val.x < 0 || val.y < 0 || val.z < 0) {
    return 0.0f;
  } else {
    return voxelBuffer[val.z*size.x*size.y + val.y*size.x + val.x];
  }
}

float3 calcNormalFor(uint3 val) {
  float3 normal = float3(
    (accessGlobalVoxelBuffer(val + int3(1, 0, 0)) - accessGlobalVoxelBuffer(val - int3(1, 0, 0)))/2.0f,
    (accessGlobalVoxelBuffer(val + int3(0, 1, 0)) - accessGlobalVoxelBuffer(val - int3(0, 1, 0)))/2.0f,
    (accessGlobalVoxelBuffer(val + int3(0, 0, 1)) - accessGlobalVoxelBuffer(val - int3(0, 0, 1)))/2.0f
  );
  if (length(normal) == 0) {
    return normal;
  } else {
    return normalize(normal);
  }
}

[numthreads(B_DIM_X, B_DIM_Y, B_DIM_Z)]
void generateTriangles(
  uint3 gid : SV_GroupID,
  uint gidx : SV_GroupIndex,
  uint3 gtid : SV_GroupThreadID
)
{
  uint3 c_gid = uint3(0, 0, 0);

  uint len = numBlocks.x*numBlocks.y*numBlocks.z;

  for(uint i = 0; i < len; i++) {
    uint blkIdx = compactedBlkArray[i];
    if (blkIdx == gid.x) {
      c_gid.x = i%numBlocks.x;
      c_gid.y = ((i-c_gid.x)/numBlocks.x)%numBlocks.y;
      c_gid.z = (((i-c_gid.x)/numBlocks.x)-c_gid.y)/numBlocks.y;
      break;
    }
  }

  uint3 gridPos = c_gid*uint3(B_DIM_X-1, B_DIM_Y-1, B_DIM_Z-1) + gtid;

  int globalIndex = gridPos.z*size.x*size.y + gridPos.y*size.x + gridPos.x;
  float myVoxelValue = voxelBuffer[globalIndex];
  sharedVoxelBuffer[gidx] = myVoxelValue;
  GroupMemoryBarrierWithGroupSync();

  uint cubeCase = 0;
  cubeCase = (cubeCase<<1)|(accessSharedVoxelBuffer(gtid + uint3(0, 1, 1)) < isoValue);
  cubeCase = (cubeCase<<1)|(accessSharedVoxelBuffer(gtid + uint3(1, 1, 1)) < isoValue);
  cubeCase = (cubeCase<<1)|(accessSharedVoxelBuffer(gtid + uint3(1, 0, 1)) < isoValue);
  cubeCase = (cubeCase<<1)|(accessSharedVoxelBuffer(gtid + uint3(0, 0, 1)) < isoValue);
  cubeCase = (cubeCase<<1)|(accessSharedVoxelBuffer(gtid + uint3(0, 1, 0)) < isoValue);
  cubeCase = (cubeCase<<1)|(accessSharedVoxelBuffer(gtid + uint3(1, 1, 0)) < isoValue);
  cubeCase = (cubeCase<<1)|(accessSharedVoxelBuffer(gtid + uint3(1, 0, 0)) < isoValue ? 1 : 0);
  cubeCase = (cubeCase<<1)|(myVoxelValue < isoValue ? 1 : 0);

  uint myNumTris = gtid.x < B_DIM_X - 1 && gtid.y < B_DIM_Y - 1 && gtid.z < B_DIM_Z - 1 ? numTrisLookup[cubeCase] : 0;
  numTris[gidx] = myNumTris;

  float3 edgeVoxels = {
    accessSharedVoxelBuffer(gtid + uint3(1, 0, 0)),
    accessSharedVoxelBuffer(gtid + uint3(0, 1, 0)),
    accessSharedVoxelBuffer(gtid + uint3(0, 0, 1))
  };

  bool3 myXyzEdges;
  if (myVoxelValue <= isoValue) {
    myXyzEdges = bool3(
      edgeVoxels.x > isoValue,
      edgeVoxels.y > isoValue,
      edgeVoxels.z > isoValue
    );
  } else {
    myXyzEdges = bool3(
      edgeVoxels.x <= isoValue,
      edgeVoxels.y <= isoValue,
      edgeVoxels.z <= isoValue
    );
  }
  sharedXyzEdges[gidx] = myXyzEdges;

  uint myNumVerts = myXyzEdges.x + myXyzEdges.y + myXyzEdges.z; 
  numVerts[gidx] = myNumVerts;

  GroupMemoryBarrierWithGroupSync();

  for (uint offset = 1; offset < B_DIM; offset <<= 1) {
    int t = numTris[gidx-offset];
    int v = numVerts[gidx-offset];
    GroupMemoryBarrierWithGroupSync();
    if (gidx >= offset) {
      numTris[gidx] += t;
      numVerts[gidx] += v;
    }
    GroupMemoryBarrierWithGroupSync();
  }

  uint trisOffset = numTris[gidx];
  uint vertsOffset = numVerts[gidx];
  if (gidx == B_DIM-1) {
    InterlockedAdd(globalVertexOffset[0], numVerts[gidx], numVerts[gidx]);
    InterlockedAdd(globalIndexOffset[0], numTris[gidx], numTris[gidx]);
  }

  AllMemoryBarrierWithGroupSync();

  uint sharedTrisOffset = numTris[B_DIM-1];
  uint sharedVertsOffset = numVerts[B_DIM-1];

  GroupMemoryBarrierWithGroupSync();

  numTris[gidx] = trisOffset + sharedTrisOffset;
  numVerts[gidx] = vertsOffset + sharedVertsOffset - myNumVerts;
  GroupMemoryBarrierWithGroupSync();

  float3 myNormalVector = calcNormalFor(gridPos);
  uint vertexOffset = numVerts[gidx];
  if (myXyzEdges.x) {
    float3 xVoxel = gridPos;
    xVoxel.x += 1;
    float delta = edgeVoxels.x - myVoxelValue;
    float lerpFactor = (delta == 0.0f) ? isoValue : (isoValue - myVoxelValue) / delta;
    normalBuffer[vertexOffset] = -lerp(myNormalVector, calcNormalFor(xVoxel), lerpFactor);
    vertexBuffer[vertexOffset] = lerp(gridPos, xVoxel, lerpFactor);
    vertexOffset++;
  }

  if (myXyzEdges.y) {
    float3 yVoxel = gridPos;
    yVoxel.y += 1;
    float delta = edgeVoxels.y - myVoxelValue;
    float lerpFactor = (delta == 0.0f) ? isoValue : (isoValue - myVoxelValue) / delta;
    normalBuffer[vertexOffset] = -lerp(myNormalVector, calcNormalFor(yVoxel), lerpFactor);
    vertexBuffer[vertexOffset] = lerp(gridPos, yVoxel, lerpFactor);
    vertexOffset++;
  }

  if (myXyzEdges.z) {
    float3 zVoxel = gridPos;
    zVoxel.z += 1;
    float delta = edgeVoxels.z - myVoxelValue;
    float lerpFactor = (delta == 0.0f) ? isoValue : (isoValue - myVoxelValue) / delta;
    normalBuffer[vertexOffset] = -lerp(myNormalVector, calcNormalFor(zVoxel), lerpFactor);
    vertexBuffer[vertexOffset] = lerp(gridPos, zVoxel, lerpFactor);
  }

  // indexBuffer[globalIndex] = numVerts[gidx];
  // return;

  uint indexBufferBaseOffset = (numTris[gidx]-myNumTris)*3;
  for (uint indexOffset = 0; indexOffset < myNumTris*3; indexOffset++) {
    uint4 edgeMap = neighborMappingTable[marchingCubesEdgeTable[cubeCase*16+indexOffset]];
    uint3 edgeCellOffset = gtid + edgeMap.xyz;
    uint edgeCellOffsetIdx = vecToIdx(edgeCellOffset);

    bool3 neighborXyzEdges = sharedXyzEdges[edgeCellOffsetIdx];
    uint edgeSum = 0;
    for(uint edgeIndex = 0; edgeIndex < edgeMap.w; edgeIndex++) {
      edgeSum += neighborXyzEdges[edgeIndex];
    }
    uint edgeVertexIndex = numVerts[edgeCellOffsetIdx]+edgeSum;
    indexBuffer[indexBufferBaseOffset+indexOffset] = edgeVertexIndex;
    //indexBuffer[indexBufferBaseOffset+indexOffset] = gidx; edgeMap.x * 1000 + edgeMap.y *100+edgeMap.z*10 + edgeMap.w;
    // indexBuffer[indexBufferBaseOffset+indexOffset] = marchingCubesEdgeTable[cubeCase*16+indexOffset];
    // indexBuffer[1000+indexBufferBaseOffset+indexOffset] = edgeCellOffset;
  }
}

