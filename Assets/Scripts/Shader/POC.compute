#pragma kernel minMax
#pragma kernel compactActiveBlocks
#pragma kernel generateTriangles

#define B_DIM_X 8
#define B_DIM_Y 4
#define B_DIM_Z 4
#define B_DIM B_DIM_X*B_DIM_Y*B_DIM_Z
#define WARP_SIZE 32

struct MinMaxPair {
  float min;
  float max;
};

int3 size;
int3 numBlocks;
int3 c_numBlocks;
RWStructuredBuffer<MinMaxPair> minMaxBuffer;

groupshared MinMaxPair sharedMinMaxBuffer[B_DIM];

RWStructuredBuffer<float> voxelBuffer;

[numthreads(B_DIM_X, B_DIM_Y, B_DIM_Z)]
void minMax (
  uint3 gtid : SV_GroupThreadID,
  uint3 gid : SV_GroupID,
  uint gidx : SV_GroupIndex
)
{
  uint gridPos = (gid.z*(B_DIM_Z-1)+gtid.z)*size.x*size.y + (gid.y*(B_DIM_Y-1)+gtid.y)*size.x + (gid.x*(B_DIM_X-1)+gtid.x);

  float val1 = voxelBuffer[gridPos];
  sharedMinMaxBuffer[gidx].min = val1;
  sharedMinMaxBuffer[gidx].max = val1;

  GroupMemoryBarrierWithGroupSync();
  for(uint i=B_DIM/2; i > 0; i>>=1) {
    if(gidx < i) {
      MinMaxPair pair1 = sharedMinMaxBuffer[gidx];
      MinMaxPair pair2 = sharedMinMaxBuffer[gidx+i];
      sharedMinMaxBuffer[gidx].min = min(pair1.min, pair2.min);
      sharedMinMaxBuffer[gidx].max = max(pair1.max, pair2.max);
    }
    GroupMemoryBarrierWithGroupSync();
  }

  if(gidx == 0) {
    minMaxBuffer[gid.z*numBlocks.x*numBlocks.y + gid.y*numBlocks.x + gid.x] = sharedMinMaxBuffer[gidx];
  }
}

extern float isoValue;
RWStructuredBuffer<uint> activeBlkNum;
RWStructuredBuffer<int> compactedBlkArray;
groupshared int sharedCompactedBlkArray[B_DIM];

[numthreads(B_DIM_X, B_DIM_Y, B_DIM_Z)]
void compactActiveBlocks(
  uint3 dtid : SV_DispatchThreadID,
  uint3 gtid : SV_GroupThreadID,
  uint3 gid : SV_GroupID,
  uint gidx : SV_GroupIndex
)
{
  uint3 numBlocksInGroup = numBlocks - gid * uint3(B_DIM_X, B_DIM_Y, B_DIM_Z);
  uint maxValidGidx = min(B_DIM, (numBlocksInGroup.z-1)*B_DIM_X*B_DIM_Y + (numBlocksInGroup.y-1)*B_DIM_X + numBlocksInGroup.x) - 1;

  bool valid = gtid.x < numBlocksInGroup.x && gtid.y < numBlocksInGroup.y && gtid.z < numBlocksInGroup.z;

  uint blockIdx = dtid.z*numBlocks.x*numBlocks.y + dtid.y*numBlocks.x + dtid.x;
  MinMaxPair pair = minMaxBuffer[blockIdx];
  bool active = pair.min < isoValue && pair.max > isoValue && valid;
  sharedCompactedBlkArray[gidx] = active;

  GroupMemoryBarrierWithGroupSync();

  for (uint offset = 1; offset < B_DIM; offset <<= 1) {
    if (gidx >= offset) {
      sharedCompactedBlkArray[gidx] += sharedCompactedBlkArray[gidx-offset];
    }
    GroupMemoryBarrierWithGroupSync();
  }

  uint index = sharedCompactedBlkArray[gidx];
  if (gidx == maxValidGidx) {
    InterlockedAdd(activeBlkNum[0], sharedCompactedBlkArray[gidx], sharedCompactedBlkArray[gidx]);
  }

  AllMemoryBarrierWithGroupSync();

  if (valid) {
    compactedBlkArray[blockIdx] = active ? index + sharedCompactedBlkArray[maxValidGidx] - 1 : -1;
  }
}

static const uint4 neighborMappingTable[] = {
  uint4(0,0,0,0),
  uint4(1,0,0,1),
  uint4(0,1,0,0),
  uint4(0,0,0,1),
  uint4(0,0,1,0),
  uint4(1,0,1,1),
  uint4(0,1,1,0),
  uint4(0,0,1,1),
  uint4(0,0,0,2),
  uint4(1,0,0,2),
  uint4(1,1,0,2),
  uint4(0,1,0,2),
};

static const uint numTrisLookup[] = {
0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,2,1,
2,2,3,2,3,3,4,2,3,3,4,3,4,4,3,1,
2,2,3,2,3,3,4,2,3,3,4,3,4,4,3,2,
3,3,2,3,4,4,3,3,4,4,3,4,5,5,2,1,
2,2,3,2,3,3,4,2,3,3,4,3,4,4,3,2,
3,3,4,3,4,4,5,3,4,4,5,4,5,5,4,2,
3,3,4,3,4,2,3,3,4,4,5,4,5,3,2,3,
4,4,3,4,5,3,2,4,5,5,4,5,2,4,1,1,
2,2,3,2,3,3,4,2,3,3,4,3,4,4,3,2,
3,3,4,3,4,4,5,3,2,4,3,4,3,5,2,2,
3,3,4,3,4,4,5,3,4,4,5,4,5,5,4,3,
4,4,3,4,5,5,4,4,3,5,2,5,4,2,1,2,
3,3,4,3,4,4,5,3,4,4,5,2,3,3,2,3,
4,4,5,4,5,5,2,4,3,5,4,3,2,4,1,3,
4,4,5,4,5,3,4,4,5,5,2,3,4,2,1,2,
3,3,2,3,4,2,1,3,2,4,1,2,1,1,0,
};

static const uint edgeTableOffset[] = {
0, 1, 2, 4, 5, 7, 9, 12, 13, 15, 17, 20, 22, 25, 28, 32, 
33, 35, 37, 40, 42, 45, 48, 52, 54, 57, 60, 64, 67, 71, 75, 80, 
81, 83, 85, 88, 90, 93, 96, 100, 102, 105, 108, 112, 115, 119, 123, 128, 
130, 133, 136, 140, 143, 147, 151, 156, 159, 163, 167, 172, 176, 181, 184, 186, 
187, 189, 191, 194, 196, 199, 202, 206, 208, 211, 214, 218, 221, 225, 229, 234, 
236, 239, 242, 246, 249, 253, 257, 262, 265, 269, 273, 278, 282, 287, 292, 296, 
298, 301, 304, 308, 311, 315, 319, 324, 327, 331, 335, 340, 344, 349, 352, 354, 
357, 361, 365, 370, 374, 379, 384, 386, 390, 395, 400, 404, 407, 409, 413, 414, 
415, 417, 419, 422, 424, 427, 430, 434, 436, 439, 442, 446, 449, 453, 457, 462, 
464, 467, 470, 474, 477, 481, 485, 490, 493, 497, 501, 506, 510, 515, 518, 520, 
522, 525, 528, 532, 535, 539, 543, 548, 551, 555, 559, 562, 566, 571, 576, 580, 
583, 587, 591, 596, 600, 605, 610, 614, 618, 623, 628, 630, 635, 639, 641, 642, 
644, 647, 650, 654, 657, 661, 665, 668, 671, 675, 679, 684, 688, 691, 696, 698, 
701, 705, 709, 714, 718, 723, 728, 730, 734, 739, 744, 748, 753, 755, 759, 760, 
763, 767, 771, 774, 778, 783, 786, 790, 794, 799, 804, 806, 811, 815, 817, 818, 
822, 827, 832, 834, 839, 843, 845, 846, 849, 851, 855, 856, 858, 859, 860, 860
};

RWStructuredBuffer<int> marchingCubesEdgeTable;
RWStructuredBuffer<float3> vertexBuffer;
RWStructuredBuffer<float3> normalBuffer;
RWStructuredBuffer<int> indexBuffer;

RWStructuredBuffer<int> globalVertexOffset;
RWStructuredBuffer<int> globalIndexOffset;

groupshared float sharedVoxelBuffer[B_DIM];
groupshared bool3 sharedXyzEdges[B_DIM];
groupshared int numVerts[B_DIM];
groupshared int numTris[B_DIM];

int vecToIdx(uint3 vec) {
  return vec.z*B_DIM_X*B_DIM_Y+vec.y*B_DIM_X+vec.x;
}

float accessSharedVoxelBuffer(uint3 val) {
  if (val.x >= B_DIM_X || val.y >= B_DIM_Y || val.z >= B_DIM_Z) {
    return 0.0f;
  } else {
    return sharedVoxelBuffer[vecToIdx(val)];
  }
}

float accessGlobalVoxelBuffer(int3 val) {
  if (val.x >= size.x || val.y >= size.y || val.z >= size.z) {
    return 0.0f;
  } else {
    return voxelBuffer[val.z*size.x*size.y + val.y*size.x + val.x];
  }
}

float3 calcNormalFor(uint3 val) {
  float3 normal = float3(
    (accessGlobalVoxelBuffer(val + uint3(1, 0, 0)) - accessGlobalVoxelBuffer(val - uint3(1, 0, 0)))/2,
    (accessGlobalVoxelBuffer(val + uint3(0, 1, 0)) - accessGlobalVoxelBuffer(val - uint3(0, 1, 0)))/2,
    (accessGlobalVoxelBuffer(val + uint3(0, 0, 1)) - accessGlobalVoxelBuffer(val - uint3(0, 0, 1)))/2
  );
  if (length(normal) == 0) {
    return normal;
  } else {
    return normalize(normal);
  }
}

[numthreads(B_DIM_X, B_DIM_Y, B_DIM_Z)]
void generateTriangles(
  uint3 gid : SV_GroupID,
  uint gidx : SV_GroupIndex,
  uint3 gtid : SV_GroupThreadID
)
{
  uint3 c_gid = uint3(0, 0, 0);

  uint len = numBlocks.x*numBlocks.y*numBlocks.z;

  for(uint i = 0; i < len; i++) {
    uint blkIdx = compactedBlkArray[i];
    if (blkIdx == gid.x) {
      c_gid.x = i%numBlocks.x;
      c_gid.y = ((i-c_gid.x)/numBlocks.x)%numBlocks.y;
      c_gid.z = (((i-c_gid.x)/numBlocks.x)-c_gid.y)/numBlocks.y;
      break;
    }
  }

  uint3 c_dtid = c_gid*uint3(B_DIM_X-1, B_DIM_Y-1, B_DIM_Z-1) + gtid;
  uint c_gidx = gtid.z*B_DIM_X*B_DIM_Y + gtid.y*B_DIM_X + gtid.x;

  int globalIndex = c_dtid.z*size.x*size.y + c_dtid.y*size.x + c_dtid.x;
  float myVoxelValue = voxelBuffer[globalIndex];
  sharedVoxelBuffer[c_gidx] = myVoxelValue;
  GroupMemoryBarrierWithGroupSync();

  uint cubeCase = 0;
  cubeCase = (cubeCase<<1)|(accessSharedVoxelBuffer(gtid + uint3(0, 1, 1)) < isoValue);
  cubeCase = (cubeCase<<1)|(accessSharedVoxelBuffer(gtid + uint3(1, 1, 1)) < isoValue);
  cubeCase = (cubeCase<<1)|(accessSharedVoxelBuffer(gtid + uint3(1, 0, 1)) < isoValue);
  cubeCase = (cubeCase<<1)|(accessSharedVoxelBuffer(gtid + uint3(0, 0, 1)) < isoValue);
  cubeCase = (cubeCase<<1)|(accessSharedVoxelBuffer(gtid + uint3(0, 1, 0)) < isoValue);
  cubeCase = (cubeCase<<1)|(accessSharedVoxelBuffer(gtid + uint3(1, 1, 0)) < isoValue);
  cubeCase = (cubeCase<<1)|(accessSharedVoxelBuffer(gtid + uint3(1, 0, 0)) < isoValue ? 1 : 0);
  cubeCase = (cubeCase<<1)|(myVoxelValue < isoValue ? 1 : 0);

  uint myNumTris = gtid.x < B_DIM_X - 1 && gtid.y < B_DIM_Y - 1 && gtid.z < B_DIM_Z - 1 ? numTrisLookup[cubeCase] : 0;
  numTris[c_gidx] = myNumTris;

  float3 edgeVoxels = {
    accessSharedVoxelBuffer(gtid + uint3(1, 0, 0)),
    accessSharedVoxelBuffer(gtid + uint3(0, 1, 0)),
    accessSharedVoxelBuffer(gtid + uint3(0, 0, 1))
  };

  bool3 myXyzEdges;
  if (myVoxelValue <= isoValue) {
    myXyzEdges = bool3(
      edgeVoxels.x > isoValue,
      edgeVoxels.y > isoValue,
      edgeVoxels.z > isoValue
    );
  } else {
    myXyzEdges = bool3(
      edgeVoxels.x <= isoValue,
      edgeVoxels.y <= isoValue,
      edgeVoxels.z <= isoValue
    );
  }
  sharedXyzEdges[c_gidx] = myXyzEdges;

  uint myNumVerts = myXyzEdges.x + myXyzEdges.y + myXyzEdges.z; 
  numVerts[c_gidx] = myNumVerts;

  GroupMemoryBarrierWithGroupSync();

  for (uint offset = 1; offset < B_DIM; offset <<= 1) {
    if (c_gidx >= offset) {
      numTris[c_gidx] += numTris[c_gidx-offset];
      numVerts[c_gidx] += numVerts[c_gidx-offset];
    }
    GroupMemoryBarrierWithGroupSync();
  }

  uint trisOffset = numTris[c_gidx];
  uint vertsOffset = numVerts[c_gidx];
  if (c_gidx == B_DIM-1) {
    InterlockedAdd(globalVertexOffset[0], numVerts[c_gidx], numVerts[c_gidx]);
    InterlockedAdd(globalIndexOffset[0], numTris[c_gidx], numTris[c_gidx]);
  }

  AllMemoryBarrierWithGroupSync();

  uint sharedTrisOffset = numTris[B_DIM-1];
  uint sharedVertsOffset = numVerts[B_DIM-1];

  GroupMemoryBarrierWithGroupSync();

  numTris[c_gidx] = trisOffset + sharedTrisOffset;
  numVerts[c_gidx] = vertsOffset + sharedVertsOffset - myNumVerts;
  GroupMemoryBarrierWithGroupSync();

  float3 myNormalVector = calcNormalFor(c_dtid);
  uint vertexOffset = numVerts[c_gidx];
  if (myXyzEdges.x) {
    float3 xVoxel = c_dtid;
    xVoxel.x += 1;
    float delta = edgeVoxels.x - myVoxelValue;
    float lerpFactor = (delta == 0.0f) ? isoValue : (isoValue - myVoxelValue) / delta;
    normalBuffer[vertexOffset] = lerp(myNormalVector, calcNormalFor(xVoxel), lerpFactor);
    vertexBuffer[vertexOffset] = lerp(c_dtid, xVoxel, lerpFactor);
    vertexOffset++;
  }

  if (myXyzEdges.y) {
    float3 yVoxel = c_dtid;
    yVoxel.y += 1;
    float delta = edgeVoxels.y - myVoxelValue;
    float lerpFactor = (delta == 0.0f) ? isoValue : (isoValue - myVoxelValue) / delta;
    normalBuffer[vertexOffset] = lerp(myNormalVector, calcNormalFor(yVoxel), lerpFactor);
    vertexBuffer[vertexOffset] = lerp(c_dtid, yVoxel, lerpFactor);
    vertexOffset++;
  }

  if (myXyzEdges.z) {
    float3 zVoxel = c_dtid;
    zVoxel.z += 1;
    float delta = edgeVoxels.z - myVoxelValue;
    float lerpFactor = (delta == 0.0f) ? isoValue : (isoValue - myVoxelValue) / delta;
    normalBuffer[vertexOffset] = lerp(myNormalVector, calcNormalFor(zVoxel), lerpFactor);
    vertexBuffer[vertexOffset] = lerp(c_dtid, zVoxel, lerpFactor);
  }

  // indexBuffer[globalIndex] = numVerts[c_gidx];
  // return;

  uint indexBufferBaseOffset = (numTris[c_gidx]-myNumTris)*3;
  for (uint indexOffset = 0; indexOffset < myNumTris*3; indexOffset++) {
    uint4 edgeMap = neighborMappingTable[marchingCubesEdgeTable[cubeCase*16+indexOffset]];
    uint3 edgeCellOffset = gtid + edgeMap.xyz;
    uint edgeCellOffsetIdx = vecToIdx(edgeCellOffset);

    bool3 neighborXyzEdges = sharedXyzEdges[edgeCellOffsetIdx];
    uint edgeSum = 0;
    for(uint edgeIndex = 0; edgeIndex < edgeMap.w; edgeIndex++) {
      edgeSum += neighborXyzEdges[edgeIndex];
    }
    uint edgeVertexIndex = numVerts[edgeCellOffsetIdx]+edgeSum;
    indexBuffer[indexBufferBaseOffset+indexOffset] = edgeVertexIndex;
    //indexBuffer[indexBufferBaseOffset+indexOffset] = c_gidx; edgeMap.x * 1000 + edgeMap.y *100+edgeMap.z*10 + edgeMap.w;
    // indexBuffer[indexBufferBaseOffset+indexOffset] = marchingCubesEdgeTable[cubeCase*16+indexOffset];
    // indexBuffer[1000+indexBufferBaseOffset+indexOffset] = edgeCellOffset;
  }
}

