#pragma kernel minMax
#pragma kernel compactActiveBlocks
#pragma kernel generateTriangles

#define B_DIM_X 8
#define B_DIM_Y 4
#define B_DIM_Z 4
#define B_DIM B_DIM_X*B_DIM_Y*B_DIM_Z
#define WARP_SIZE 32

struct MinMaxPair {
  float min;
  float max;
};

int3 size;
int3 numBlocks;
RWStructuredBuffer<MinMaxPair> minMaxBuffer;

groupshared MinMaxPair sharedMinMaxBuffer[B_DIM];

RWStructuredBuffer<float> voxelBuffer;

[numthreads(B_DIM_X, B_DIM_Y, B_DIM_Z)]
void minMax (
  uint3 dtid : SV_DispatchThreadID,
  uint3 gid : SV_GroupID,
  uint gidx : SV_GroupIndex
)
{
  uint globalIndex = dtid.z*size.x*size.y + dtid.y*size.x + dtid.x;

  float val1 = voxelBuffer[globalIndex];
  sharedMinMaxBuffer[gidx].min = val1;
  sharedMinMaxBuffer[gidx].max = val1;

  GroupMemoryBarrierWithGroupSync();
  for(uint i=B_DIM/2; i > 0; i>>=1) {
    if(gidx < i) {
      MinMaxPair pair1 = sharedMinMaxBuffer[gidx];
      MinMaxPair pair2 = sharedMinMaxBuffer[gidx+i];
      sharedMinMaxBuffer[gidx].min = min(pair1.min, pair2.min);
      sharedMinMaxBuffer[gidx].max = max(pair1.max, pair2.max);
    }
    GroupMemoryBarrierWithGroupSync();
  }

  if(gidx == 0) {
    minMaxBuffer[gid.z*numBlocks.x*numBlocks.y + gid.y*numBlocks.x + gid.x] = sharedMinMaxBuffer[gidx];
  }
}

extern float isoValue;
RWStructuredBuffer<uint> activeBlkNum;
RWStructuredBuffer<int> compactedBlkArray;
groupshared int sharedCompactedBlkArray[B_DIM];

[numthreads(8, 4, 4)]
void compactActiveBlocks(
  uint3 dtid : SV_DispatchThreadID,
  uint3 gtid : SV_GroupThreadID,
  uint3 gid : SV_GroupID,
  uint gidx : SV_GroupIndex
)
{
  uint3 numBlocksInGroup = numBlocks - gid * uint3(B_DIM_X, B_DIM_Y, B_DIM_Z);
  uint maxValidGidx = min(B_DIM, (numBlocksInGroup.z-1)*B_DIM_X*B_DIM_Y + (numBlocksInGroup.y-1)*B_DIM_X + numBlocksInGroup.x) - 1;

  bool valid = gtid.x < numBlocksInGroup.x && gtid.y < numBlocksInGroup.y && gtid.z < numBlocksInGroup.z;

  uint blockIdx = dtid.z*numBlocks.x*numBlocks.y + dtid.y*numBlocks.x + dtid.x;
  MinMaxPair pair = minMaxBuffer[blockIdx];
  bool active = pair.min < isoValue && pair.max > isoValue && valid;
  sharedCompactedBlkArray[gidx] = active;

  GroupMemoryBarrierWithGroupSync();

  for (uint offset = 1; offset < B_DIM; offset <<= 1) {
    if (gidx >= offset) {
      sharedCompactedBlkArray[gidx] += sharedCompactedBlkArray[gidx-offset];
    }
    GroupMemoryBarrierWithGroupSync();
  }

  uint index = sharedCompactedBlkArray[gidx];
  if (gidx == maxValidGidx) {
    InterlockedAdd(activeBlkNum[0], sharedCompactedBlkArray[gidx], sharedCompactedBlkArray[gidx]);
  }

  AllMemoryBarrierWithGroupSync();

  if (valid) {
    compactedBlkArray[blockIdx] = active ? index + sharedCompactedBlkArray[maxValidGidx] - 1 : -1;
  }
}

const uint numTrisLookup[] = {

};

RWStructuredBuffer<float3> vertexBuffer;
RWStructuredBuffer<float3> normalBuffer;
RWStructuredBuffer<int> indexBuffer;

groupshared float3 sharedVoxelBuffer[B_DIM];
groupshared bool3 sharedXyzEdges[B_DIM];
groupshared int numVerts[B_DIM];
groupshared int numTris[B_DIM];

[numthreads(B_DIM_X, B_DIM_Y, B_DIM_Z)]
void generateTriangles(
  uint3 gid : SV_GroupID,
  uint3 dtid : SV_DispatchThreadID,
  uint3 gtid : SV_GroupThreadID,
  uint gidx : SV_GroupIndex
)
{
  int activeBlkIdx = gid.z*numBlocks.x*numBlocks.y+gid.y*numBlocks.x+gid.z;
  if (compactedBlkArray[activeBlkIdx] == -1) {
    return;
  }

  int globalIndex = dtid.z*size.x*size.y + dtid.y*size.x + dtid.z;
  float myVoxelValue = voxelBuffer[globalIndex]; 
  sharedVoxelBuffer[gidx] = myVoxelValue;
  GroupMemoryBarrierWithGroupSync();

  float3 edgeVoxels = float3(
    sharedVoxelBuffer[gidx+1],
    sharedVoxelBuffer[gidx+B_DIM_X],
    sharedVoxelBuffer[gidx+B_DIM_X*B_DIM_Y]
  );

  if (myVoxelValue <= isoValue) {
    sharedXyzEdges[gidx] = bool3(
      edgeVoxels.x > isoValue,
      edgeVoxels.y > isoValue,
      edgeVoxels.z > isoValue
    );
  } else {
    sharedXyzEdges[gidx] = bool3(
      edgeVoxels.x <= isoValue,
      edgeVoxels.y <= isoValue,
      edgeVoxels.z <= isoValue
    );
  }

  numVerts[gidx] = edgeVoxels.x + edgeVoxels.y + edgeVoxels.z;

}

