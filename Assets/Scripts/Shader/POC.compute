#pragma kernel minMax
#pragma kernel compactActiveBlocks

#define B_DIM_X 8
#define B_DIM_Y 4
#define B_DIM_Z 4
#define B_DIM B_DIM_X*B_DIM_Y*B_DIM_Z
#define WARP_SIZE 32

struct MinMaxPair {
  float min;
  float max;
};

int3 size;
int3 numBlocks;
RWStructuredBuffer<MinMaxPair> minMaxBuffer;

groupshared MinMaxPair sharedMinMaxBuffer[B_DIM];

RWStructuredBuffer<float> voxelBuffer;

[numthreads(B_DIM_X, B_DIM_Y, B_DIM_Z)]
void minMax (
  uint3 dtid : SV_DispatchThreadID,
  uint3 gid : SV_GroupID,
  uint gidx : SV_GroupIndex
)
{
  uint globalIndex = dtid.z*size.x*size.y + dtid.y*size.x + dtid.x;

  float val1 = voxelBuffer[globalIndex];
  sharedMinMaxBuffer[gidx].min = val1;
  sharedMinMaxBuffer[gidx].max = val1;

  GroupMemoryBarrierWithGroupSync();
  for(uint i=B_DIM/2; i > 0; i>>=1) {
    if(gidx < i) {
      MinMaxPair pair1 = sharedMinMaxBuffer[gidx];
      MinMaxPair pair2 = sharedMinMaxBuffer[gidx+i];
      sharedMinMaxBuffer[gidx].min = min(pair1.min, pair2.min);
      sharedMinMaxBuffer[gidx].max = max(pair1.max, pair2.max);
    }
    GroupMemoryBarrierWithGroupSync();
  }

  if(gidx == 0) {
    minMaxBuffer[gid.z*numBlocks.x*numBlocks.y + gid.y*numBlocks.x + gid.x] = sharedMinMaxBuffer[gidx];
  }
}

extern float isoValue;
RWStructuredBuffer<uint> activeBlkNum;
RWStructuredBuffer<int> compactedBlkArray;
groupshared int sharedCompactedBlkArray[B_DIM];

[numthreads(8, 4, 4)]
void compactActiveBlocks(
  uint3 dtid : SV_DispatchThreadID,
  uint3 gtid : SV_GroupThreadID,
  uint3 gid : SV_GroupID,
  uint gidx : SV_GroupIndex
)
{
  uint3 numBlocksInGroup = numBlocks - gid * uint3(B_DIM_X, B_DIM_Y, B_DIM_Z);
  uint maxValidGidx = min(B_DIM, (numBlocksInGroup.z-1)*B_DIM_X*B_DIM_Y + (numBlocksInGroup.y-1)*B_DIM_X + numBlocksInGroup.x) - 1;

  bool valid = gtid.x < numBlocksInGroup.x && gtid.y < numBlocksInGroup.y && gtid.z < numBlocksInGroup.z;

  uint blockIdx = dtid.z*numBlocks.x*numBlocks.y + dtid.y*numBlocks.x + dtid.x;
  MinMaxPair pair = minMaxBuffer[blockIdx];
  bool active = pair.min < isoValue && pair.max > isoValue && valid;
  sharedCompactedBlkArray[gidx] = active;

  GroupMemoryBarrierWithGroupSync();

  for (uint offset = 1; offset < B_DIM; offset <<= 1) {
    if (gidx >= offset) {
      sharedCompactedBlkArray[gidx] += sharedCompactedBlkArray[gidx-offset];
    }
    GroupMemoryBarrierWithGroupSync();
  }

  uint index = sharedCompactedBlkArray[gidx];
  int activeBlocks = 0;
  if (gidx == maxValidGidx) {
    InterlockedAdd(activeBlkNum[0], index, activeBlocks);
  }

  AllMemoryBarrierWithGroupSync();

  if (valid) {
    compactedBlkArray[blockIdx] = active ? index + activeBlocks - 1 : -1;
  }
}
