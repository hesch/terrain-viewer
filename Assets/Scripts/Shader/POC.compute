#pragma kernel minMax
#pragma kernel compactActiveBlocks

#define B_DIM_X 8
#define B_DIM_Y 4
#define B_DIM_Z 4
#define B_DIM B_DIM_X*B_DIM_Y*B_DIM_Z
#define WARP_SIZE 32

struct MinMaxPair {
  float min;
  float max;
};

int3 size;
int3 numBlocks;
RWStructuredBuffer<MinMaxPair> minMaxBuffer;

groupshared MinMaxPair sharedMinMaxBuffer[B_DIM];

RWStructuredBuffer<float> voxelBuffer;

[numthreads(B_DIM_X, B_DIM_Y, B_DIM_Z)]
void minMax (
  uint3 dtid : SV_DispatchThreadID,
  uint3 gid : SV_GroupID,
  uint gidx : SV_GroupIndex
)
{
  uint globalIndex = dtid.z*size.x*size.y + dtid.y*size.x + dtid.x;

  float val1 = voxelBuffer[globalIndex];
  sharedMinMaxBuffer[gidx].min = val1;
  sharedMinMaxBuffer[gidx].max = val1;

  GroupMemoryBarrierWithGroupSync();
  for(uint i=B_DIM/2; i > 0; i>>=1) {
    if(gidx < i) {
      MinMaxPair pair1 = sharedMinMaxBuffer[gidx];
      MinMaxPair pair2 = sharedMinMaxBuffer[gidx+i];
      sharedMinMaxBuffer[gidx].min = min(pair1.min, pair2.min);
      sharedMinMaxBuffer[gidx].max = max(pair1.max, pair2.max);
    }
    GroupMemoryBarrierWithGroupSync();
  }

  if(gidx == 0) {
    minMaxBuffer[gid.z*numBlocks.x*numBlocks.y + gid.y*numBlocks.x + gid.x] = sharedMinMaxBuffer[gidx];
  }
}

float isoValue;
int activeBlkNum = 0;
int compactedBlkArray[numBlocks.x*numBlocks.y*numBlocks.z];
groupshared int sharedCompactedBlkArray[B_DIM]

[numthreads(8, 4, 4)]
void compactActiveBlocks(
  uint3 dtid : SV_DispatchThreadID,
  uint gidx : SV_GroupIndex
)
{
  uint blockIdx = dtid.z*numBlocks.x*numBlocks.y + dtid.y*numBlocks.x + dtid.x;
  MinMaxPair pair = minMaxBuffer[blockIdx];
  bool active = pair.min < isoValue && pair.max > isoValue;
  sharedCompactedBlkArray[gidx] = active;
  GroupMemoryBarrierWithGroupSync();

  for (int offset = 1; offset < B_DIM; offset <<= 1) {
    if (gidx > offset) {
      sharedCompactedBlkArray[gidx] += sharedCompactedBlkArray[gidx+offset];
    }
    GroupMemoryBarrierWithGroupSync();
  }

  int activeBlocks;
  if (gidx == 3*8*4+3*4+7) {
    InterlockedAdd(activeBlkNum, sharedCompactedBlkArray[gidx], activeBlocks);
  }
  AllMemoryBarrierWithGroupSync();

  compactedBlkArray[blockIdx] = sharedCompactedBlkArray[gidx] + activeBlocks;
}
